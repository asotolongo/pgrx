__author__ = 'anthony'
from db import databasepg,log
import config as conf
import queries as queries
import  sys



class recom(object):

    def __init__(self, arg=None):
        self.con = arg
        self.toc = ["**Recommendations  generated by the pgrx**"]
        self.toc.append("==========================")
        self.toc.append(" * Suggestions")

    def connect_db(self):
        try:
            return databasepg(conf.PASS, conf.SERVERP, conf.BBDD, conf.USERP, conf.PORTP)
        except ImportError, e:
            print "Error for connect  to BD:", str(e)
            sys.exit()

    def conex(self):
        self.con = self.connect_db()

    def recom_conf_param(self):
        return None

    def recom_conf_pg_hba(self):
        dat = self.con.executequery(queries.recom_conf_pg_hba)
        if len(dat) > 0 :
            r = "\n\n" + '**Must check access method in pg_hba.conf file** <a name="pgha"></a>'+"\n\n"
            self.toc.append('    * [pg_hba](#pgha)')
            r = r + "Line | Entry "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(dat[0]) + " | " + str(dat[1])
            return r + "\n\n"
        return  ""

    def recom_func_conex_vs_total_conex(self):
        dat = self.con.executequery(queries.recom_func_conex_vs_total_conex)
        if dat[0][0] > conf.conex_threshold:
            r = "\n\n" + '**Must consider more max_connections** <a name="max_c"></a> '+"\n\n"
            self.toc.append('    * [max_connections](#max_c)')
            return r+"\n\n"
        return ""

    def recom_conf_shared_buffer(self):
        dat = self.con.executequery(queries.recom_conf_shared_buffer)
        if dat[0][0] < conf.sb_threshold:
            r = "\n\n" + '**Must consider more shared_buffer** <a name="sha_b"></a> '+"\n\n"
            self.toc.append('    * [Shared buffers](#sha_b)')
            return r+"\n\n"
        return ""

    def recom_func_idle_in_trans(self):
        dat = self.con.executequery(str(queries.recom_func_idle_in_trans).replace('_$1_', conf.idle_in_tx_threshold))
        if len(dat) > 0 :
            r = "\n\n" + '**Must check the following conextion in pg_stat_activity, they are in idle in transaction** <a name="idle_intx"></a> '+"\n\n"
            self.toc.append('    * [Idle in transactions](#idle_intx)')
            r = r + "Pid | From | Query | Since "
            r = r + "\n" + "--- | --- |--- | ---"
            for d in dat:
                r = r + "\n" + str(dat[0]) + " | " + str(dat[1])+ " | " + str(dat[2])+ " | " + str(dat[3])
            return r+"\n\n"
        return  ""

    def recom_ddl_object_name_key_word(self):
        dat = self.con.executequery(queries.recom_ddl_object_name_key_word)
        if len(dat) > 0:
            r = "\n\n" + '**Must check  attributes name of these tables, they use keyword on attributes** <a name="key"></a>'+"\n\n"
            self.toc.append('    * [Attributes with keywords](#key)')
            r = r + "Column | Tables "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_ddl_table_without_pk(self):
        dat = self.con.executequery(queries.recom_ddl_table_without_pk)
        if len(dat) > 0:
            r = "\n\n" + '**Must check the following tables without Primary Key** <a name="nopk"></a>'+"\n\n"
            self.toc.append('    * [Tables without Primary Key](#nopk)')
            r = r + "Schema | Table "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_ddl_fk_without_index(self):
        dat = self.con.executequery(queries.recom_ddl_fk_without_index)
        if len(dat) > 0:
            r = "\n\n" + '**Must check the following foreigns keys, probably need an index** <a name="fknoindex"></a>'+"\n\n"
            self.toc.append('    * [Foreigns key without index](#fknoindex)')
            r = r + "Table | Column  | Foreign key  | Referenced_table "
            r = r + "\n" + "--- | --- | --- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])+ " | " + str(d[2])+ " | " + str(d[3])
            return r+"\n\n"
        return ""

    def recom_ddl_index_unsued(self):
        dat = self.con.executequery(queries.recom_ddl_index_unsued)
        if len(dat) > 0:
            r = "\n\n" + '**Must check the following indexes, never used** <a name="unindex"></a>'+"\n\n"
            self.toc.append('    * [Indexes unused](#unindex)')
            r = r + "Table | Index "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_ddl_index_invalid(self):
        dat = self.con.executequery(queries.recom_ddl_index_invalid)
        if len(dat) > 0:
            r = "\n\n" + '**Must check the following indexes, are invalid** <a name="invalidndex"></a>'+"\n\n"
            self.toc.append('    * [Indexes invalid](#invalidndex)')
            r = r + "Schema | Index "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_ddl_cero_one_column_table(self):
        dat = self.con.executequery(queries.recom_ddl_cero_one_column_table)
        if len(dat) > 0:
            r = "\n\n" +'**Must check the following table with 0 or 1 column, ** <a name="tablecol"></a> '+"\n\n"
            self.toc.append('    * [Tables with 0 or 1 column](#tablecol)')
            r = r + "Table | Columns count  "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_ddl_column_money(self):
        dat = self.con.executequery(queries.recom_ddl_column_money)
        if len(dat) > 0:
            r = "\n\n" +'**Must check the following tables with money data type column ** <a name="tablecol"></a>'+"\n\n"
            self.toc.append('    * [Tables with colunm with money data type](#tablecol)')
            r = r + "Table | Columns   "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_func_table_bloat(self):
        dat = self.con.executequery(queries.recom_func_table_bloat)
        if len(dat) > 0:
            r = "\n\n" +'**Must check the following tables,  posible bloat, consider VACUUM full ** <a name="tablebloat"></a>'+"\n\n"
            self.toc.append('    * [Tables bloat to consider VACUUM full](#tablebloat)')
            r = r + "Table | Bloat Ratio   "
            r = r + "\n" + "--- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1])
            return r+"\n\n"
        return ""

    def recom_func_index_bloat(self):
        dat = self.con.executequery(queries.recom_func_index_bloat)
        if len(dat) > 0:
            r = "\n\n" +'**Must check the following indexes, posible bloat, consider REINDEX  ** <a name="indexbloat"></a>'+"\n\n"
            self.toc.append('    * [Tables bloat to consider REINDEX](#indexbloat)')
            r = r + "Schema | Tabble->Idx | Idx_Size | Bloat Ratio   "
            r = r + "\n" + "--- | --- | --- | --- "
            for d in dat:
                r = r + "\n" + str(d[0]) + " | " + str(d[1]) + " | " + str(d[2]) + " | " + str(d[3])
            return r+"\n\n"
        return ""

    def recom_func_frozen(self):
        dat = self.con.executequery("select round(((age(datfrozenxid)::numeric*100)/current_setting('autovacuum_freeze_max_age')::numeric ),4) from pg_database where datname = current_database()")
        if dat[0][0] > 90:
            r = "\n\n" +'**Must consider execute vacuum freeze**  <a name="freeze"></a> '+"\n\n"
            self.toc.append('    * [Tables bloat to consider vaccum full](#freeze)')
            r = r + "\n" + "Percent or TXID age : " + str(dat[0][0])
            return r+"\n\n"
        return ""

    def recom_ddl_compiletime_runtime_checks_plpgsql(self):
        dat = self.con.executequery(queries.recom_ddl_compiletime_runtime_checks_plpgsql)
        schemas = self.con.executequery(queries.recom_ddl_compiletime_runtime_checks_plpgsql_2)
        pl = []
        for d in dat:
            fun = d[0]
            cod  = d[1]
            temp_con =  databasepg(conf.PASS, conf.SERVERP, conf.BBDD, conf.USERP, conf.PORTP)
            temp_con.executupdateequery("SET search_path = "+schemas[0][0])
            temp_con.executupdateequery("SET plpgsql.extra_warnings TO 'all';")
            temp_con.executupdateequery(cod)
            if len(temp_con.connecction.notices)>0:
                pl.append( [fun, temp_con.connecction.notices[-1]])
            temp_con.disconect()
        if len(pl)>0:
            r = "\n\n" +'**Must consider check the following warnings  plpgsql function code**  <a name="pl"></a> '+"\n\n"
            self.toc.append('    * [Warnings  plpgsql function code](#pl)')
            r = r + "Function | Warning   "
            r = r + "\n" + "--- | --- "
            for p in pl:
                r = r + "\n" + str(p[0]) + " | " + str(p[1]).replace("\n"," ")
            return r + "\n\n"
        return ""
